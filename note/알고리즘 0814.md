최대값 최소값 구할때 리스트 자체를 넣으면 인덱스 구하기 힘들다.

그래서 범위를 지정해서  for문 돌려 인덱스 값을 구함.



num = 49679

카운팅 할 때

0부터 9까지 count 리스트를 만들고

count = [0]*10

```python
48679 % 10 ->
num //= 10 4967
count[num%10] += 1
```

인덱스를 구해야함

```python
def find(data, c):
    while data !=0:
        C[data % 10] += 1
        data //= 10
      
    max Index = 0
    for i n range(1, 10):
        if(c[maxindex] <= c[i])
        maxindex = i
    return maxindex

T- int(input())
for test_case in range(1, T + 1):
    c = [] * 10
    N = int(input()
           
           data = int(input())
           ans - find(data, c)
```



리스트 앞에 값 넣을때 insert 뒤에는 append



2차원 list를 받는 방법

```python
import sys
sys.stdin = open("input.txt")

T = int(input())

for tc in range(T):
    row, col = map(int, input().split())
    data = [[0 for _ in range(col)] for _ in range(row)]
    for i in range(row):
        data[i] = list(map(int, input().split()))

    for i in range(row):
        for j in range(col):
            print(data[i][j], end=" ")
        print()
```

두번째 방법

```python
T = int(input())

for tc in range(T):
    row, col = map(int, input().split())
    data = [[0 for _ in range(col)] for _ in range(row)]
    data = [list(map(int, input()split())) for _ in range(row)]
    print(data)
```

행 우선 순회

```python
# i 행의 좌표
# j 열의 좌표
for i in range(len(array)):
    for j int range(len(array[i])):
        array[i][j] #필요한 연산 수행
```

델타를 이용한 2차 배열 탐색

```python
ary[0...n-1][0...n-1]
dx[] <- [0, 0, -1, 1] #상하좌우
dy[] <- [-1, 1, 0, 0]

for x in range(len(ary)):
    for y in range(len(ary[x])):
        for mode in range(4):
        	testx <- x + dx[mode]
        	testy <- y + dy[mode]
        	test(ary[testx][testy])
```



전치행렬

```python
# i : 행의 좌표, len(arr)
# j : 열의 좌표, len(arr[0])
arr = [[1,2,3,], [4,5,6], [7,8,9]] # 3*3 행렬

for i in range(3):
    for j in range(3):
        if i < j:
            arr[i][j], arr[j][i] = arr[j][i], arr[i][j]

for i in range(len(arr)):
    for j in range(len(arr[i])):
        print(arr[i][j], end=" ")
    print()
```

